<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dijkstra Code Visualizer — Code-Bound Player</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root { --bg: #0a0f1d; --panel: rgba(255,255,255,0.06); --card: rgba(255,255,255,0.08); --stroke: rgba(255,255,255,0.12); --text: #eaf2ff; --muted: #9fb3d1; --accent: #7cf7ff; --accent-2: #ff9f7f; --queued: #b7c9ff; --shadow: 0 18px 70px rgba(0,0,0,0.35); }
    * { box-sizing: border-box; }
    body { margin: 0; min-height: 100vh; font-family: "Space Grotesk","Segoe UI",sans-serif; background: radial-gradient(circle at 15% 10%, rgba(124,247,255,0.12), transparent 35%), radial-gradient(circle at 80% 0%, rgba(255,159,127,0.12), transparent 30%), linear-gradient(135deg,#0b132c 0%,#090f20 55%,#070d1a 100%); color: var(--text); padding: 24px; }
    .page { max-width: 1240px; margin: 0 auto 40px; display: flex; flex-direction: column; gap: 16px; }
    header { display: flex; flex-wrap: wrap; gap: 10px; justify-content: space-between; align-items: baseline; }
    h1 { margin: 0; font-size: 32px; letter-spacing: -0.02em; }
    .tagline { margin: 4px 0 0; max-width: 820px; color: var(--muted); line-height: 1.4; }
    .badge { padding: 8px 12px; background: rgba(124,247,255,0.1); border: 1px solid rgba(124,247,255,0.45); border-radius: 12px; font-size: 14px; }
    .layout { display: grid; grid-template-columns: minmax(320px,360px) 1fr; gap: 16px; }
    .panel { background: var(--panel); border: 1px solid var(--stroke); border-radius: 16px; padding: 16px; box-shadow: var(--shadow); }
    .panel h2 { margin: 0 0 8px; font-size: 18px; letter-spacing: 0.01em; }
    .copy { margin: 0 0 12px; color: var(--muted); line-height: 1.5; }
    label { display: block; font-size: 12px; text-transform: uppercase; letter-spacing: 0.05em; color: var(--muted); margin-bottom: 6px; }
    select, button, textarea { width: 100%; padding: 11px 12px; border-radius: 10px; border: 1px solid var(--stroke); background: rgba(255,255,255,0.06); color: var(--text); font-size: 15px; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease, border 0.2s ease; }
    select:focus, textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(124,247,255,0.2); }
    textarea { font-family: "Fira Code", monospace; font-size: 13px; min-height: 110px; resize: vertical; line-height: 1.4; cursor: text; }
    button.primary { background: linear-gradient(120deg,#7cf7ff 0%,#7de0ff 50%,#a9f1ff 100%); color: #04121c; border-color: rgba(124,247,255,0.6); box-shadow: 0 12px 30px rgba(124,247,255,0.2); font-weight: 700; }
    button.ghost { background: transparent; border-color: rgba(255,255,255,0.2); box-shadow: none; }
    button:hover { transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
    .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }
    .controls .wide { grid-column: span 2; }
    .legend { display: grid; grid-template-columns: auto 1fr; gap: 6px 10px; padding: 12px; border-radius: 12px; border: 1px solid var(--stroke); background: var(--card); color: var(--muted); font-size: 14px; }
    .dot { width: 12px; height: 12px; border-radius: 50%; margin-top: 3px; }
    .dot.current { background: var(--accent-2); box-shadow: 0 0 0 4px rgba(255,159,127,0.1); }
    .dot.settled { background: var(--accent); box-shadow: 0 0 0 4px rgba(124,247,255,0.08); }
    .dot.frontier { background: var(--queued); box-shadow: 0 0 0 4px rgba(183,201,255,0.1); }
    .log { margin-top: 12px; padding: 12px; background: rgba(255,255,255,0.04); border-radius: 12px; border: 1px solid var(--stroke); max-height: 240px; overflow: auto; font-family: "Fira Code", monospace; font-size: 14px; line-height: 1.45; }
    .log-entry { margin: 0 0 6px; color: var(--muted); }
    .player { display: flex; flex-direction: column; gap: 12px; min-height: 560px; }
    .player-head { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
    .status { color: var(--muted); font-size: 15px; }
    .playback { display: flex; gap: 10px; align-items: center; }
    .playback button { width: auto; padding: 9px 14px; font-size: 14px; }
    .player-body { display: grid; grid-template-columns: minmax(320px, 420px) 1fr; gap: 14px; }
    .code-pane { background: rgba(255,255,255,0.02); border: 1px solid var(--stroke); border-radius: 12px; padding: 12px 10px; font-family: "Fira Code", monospace; font-size: 13px; line-height: 1.45; }
    .code-line { display: grid; grid-template-columns: 32px 1fr; gap: 10px; padding: 6px 8px; border-radius: 8px; transition: background 0.2s ease, border 0.2s ease; border: 1px solid transparent; color: var(--text); }
    .code-line .ln { color: var(--muted); text-align: right; }
    .code-line.highlight { background: rgba(124,247,255,0.08); border-color: rgba(124,247,255,0.4); box-shadow: 0 6px 18px rgba(124,247,255,0.12); }
    .visual { background: rgba(255,255,255,0.02); border: 1px solid var(--stroke); border-radius: 12px; padding: 12px; display: flex; flex-direction: column; gap: 10px; }
    .svg-shell { position: relative; border-radius: 12px; border: 1px solid var(--stroke); background: radial-gradient(circle at 30% 30%, rgba(124,247,255,0.08), transparent 40%), radial-gradient(circle at 70% 10%, rgba(255,159,127,0.08), transparent 30%), rgba(255,255,255,0.02); flex: 1; overflow: hidden; min-height: 420px; }
    svg { width: 100%; height: 100%; display: block; filter: drop-shadow(0 10px 22px rgba(0,0,0,0.25)); }
    line.edge { stroke: #7f8fb0; stroke-width: 2.4; stroke-linecap: round; opacity: 0.65; transition: opacity 0.25s ease, stroke 0.25s ease; }
    line.edge.highlight { stroke: var(--accent-2); opacity: 0.95; }
    g.node { transition: transform 0.3s ease; }
    g.node circle { fill: url(#nodeGradient); stroke: #e5f1ff; stroke-width: 1.5; transition: fill 0.2s ease, stroke 0.2s ease, r 0.2s ease, opacity 0.2s ease; }
    g.node.settled circle { fill: #c5f5ff; stroke: var(--accent); }
    g.node.frontier circle { fill: #dfe6ff; stroke: var(--queued); }
    g.node.current circle { fill: #ffd5c4; stroke: var(--accent-2); r: 24; }
    g.node text.value { fill: #04121c; font-weight: 700; font-size: 14px; }
    g.node text.meta { fill: #f8fbff; font-size: 11px; opacity: 0.8; }
    .frame-footnote { position: absolute; left: 12px; bottom: 12px; background: rgba(0,0,0,0.3); border-radius: 10px; padding: 9px 10px; border: 1px solid rgba(255,255,255,0.12); color: var(--muted); font-size: 14px; max-width: 72%; }
    .timeline { display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--muted); }
    .timeline strong { color: var(--text); letter-spacing: 0.02em; }
    .queue-rail { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .queue-item { min-width: 60px; padding: 8px 10px; border-radius: 10px; background: rgba(183,201,255,0.12); border: 1px solid rgba(183,201,255,0.4); color: var(--text); font-weight: 700; text-align: center; box-shadow: 0 8px 20px rgba(183,201,255,0.2); }
    @media (max-width: 980px) { .layout { grid-template-columns: 1fr; } .player-body { grid-template-columns: 1fr; } body { padding: 18px; } }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div>
        <h1>Dijkstra Code Visualizer — Code-Bound Player</h1>
        <p class="tagline">Left: computePaths code. Right: queue + graph. Each step highlights the lines driving the state change.</p>
      </div>
      <div class="badge">Time: O((V+E) log V)</div>
    </header>

    <div class="layout">
      <section class="panel">
        <h2>Controls</h2>
        <p class="copy">Pick a start vertex, run, then step through queue pops and relaxations with line highlights.</p>
        <div class="controls">
          <div>
            <label for="startSelect">Start vertex</label>
            <select id="startSelect">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </div>
          <div class="wide" style="display:flex; gap:10px;">
            <button id="runBtn" class="primary">Run Dijkstra</button>
            <button id="resetBtn" class="ghost">Reset</button>
          </div>
          <div class="wide">
            <button id="sampleBtn" class="ghost">Replay sample (start = 1)</button>
          </div>
          <div class="wide">
            <label for="graphInput">Custom graph (format: 1:2(7),3(9))</label>
            <textarea id="graphInput" spellcheck="false">1:2(7),3(9),6(14)
2:3(10),4(15)
3:4(11),6(2)
4:5(6)
5:6(9)
6:</textarea>
            <div style="display:flex; gap:10px; margin-top:8px;">
              <button id="applyGraphBtn" class="ghost">Apply graph</button>
              <button id="clearGraphBtn" class="ghost">Clear</button>
            </div>
          </div>
        </div>

        <div class="legend">
          <span class="dot current"></span><span>Current (popped) vertex</span>
          <span class="dot settled"></span><span>Settled (distance finalized)</span>
          <span class="dot frontier"></span><span>In priority queue</span>
        </div>

        <div>
          <label>Priority queue (min-dist)</label>
          <div class="queue-rail" id="queueRail"></div>
        </div>

        <div class="log" id="eventLog" aria-live="polite"></div>
      </section>

      <section class="panel player">
        <div class="player-head">
          <div class="status" id="statusText">Waiting for an operation…</div>
          <div class="playback">
            <button id="prevBtn" class="ghost">Prev</button>
            <button id="playBtn" class="primary">Play</button>
            <button id="pauseBtn" class="ghost" disabled>Pause</button>
            <button id="nextBtn" class="ghost">Next</button>
          </div>
        </div>

        <div class="player-body">
          <div class="code-pane" id="codePane">
            <div class="code-line" data-line="1"><span class="ln">1</span><span>void computePaths(Vertex source) {</span></div>
            <div class="code-line" data-line="2"><span class="ln">2</span><span>  source.minDistance = 0;</span></div>
            <div class="code-line" data-line="3"><span class="ln">3</span><span>  PriorityQueue&lt;Vertex&gt; pq = new PriorityQueue&lt;&gt;();</span></div>
            <div class="code-line" data-line="4"><span class="ln">4</span><span>  pq.add(source);</span></div>
            <div class="code-line" data-line="5"><span class="ln">5</span><span>  while (!pq.isEmpty()) {</span></div>
            <div class="code-line" data-line="6"><span class="ln">6</span><span>    Vertex u = pq.poll();</span></div>
            <div class="code-line" data-line="7"><span class="ln">7</span><span>    for (Edge e : u.adjacent) {</span></div>
            <div class="code-line" data-line="8"><span class="ln">8</span><span>      Vertex v = e.target;</span></div>
            <div class="code-line" data-line="9"><span class="ln">9</span><span>      double newDist = u.minDistance + e.weight;</span></div>
            <div class="code-line" data-line="10"><span class="ln">10</span><span>      if (newDist &lt; v.minDistance) {</span></div>
            <div class="code-line" data-line="11"><span class="ln">11</span><span>        pq.remove(v);</span></div>
            <div class="code-line" data-line="12"><span class="ln">12</span><span>        v.minDistance = newDist;</span></div>
            <div class="code-line" data-line="13"><span class="ln">13</span><span>        v.predecessor = u;</span></div>
            <div class="code-line" data-line="14"><span class="ln">14</span><span>        pq.add(v);</span></div>
            <div class="code-line" data-line="15"><span class="ln">15</span><span>      }</span></div>
            <div class="code-line" data-line="16"><span class="ln">16</span><span>    }</span></div>
            <div class="code-line" data-line="17"><span class="ln">17</span><span>  }</span></div>
            <div class="code-line" data-line="18"><span class="ln">18</span><span>}</span></div>
          </div>

          <div class="visual">
            <div class="svg-shell">
              <svg id="graphSvg" viewBox="0 0 840 520" aria-label="Dijkstra animation">
                <defs>
                  <linearGradient id="nodeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#f1fbff" />
                    <stop offset="100%" stop-color="#b6e8ff" />
                  </linearGradient>
                </defs>
                <g id="edges"></g>
                <g id="nodes"></g>
              </svg>
              <div class="frame-footnote" id="frameNote">Run Dijkstra to see code and graph advance together.</div>
            </div>
            <div class="timeline">
              <strong id="frameCount">0 / 0</strong>
              <span>frames captured</span>
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>
    const svgNS = "http://www.w3.org/2000/svg";

    let graph = {
      1: [{ to: 2, w: 7 }, { to: 3, w: 9 }, { to: 6, w: 14 }],
      2: [{ to: 3, w: 10 }, { to: 4, w: 15 }],
      3: [{ to: 4, w: 11 }, { to: 6, w: 2 }],
      4: [{ to: 5, w: 6 }],
      5: [{ to: 6, w: 9 }],
      6: []
    };

    let positions = {
      1: { x: 140, y: 140 },
      2: { x: 300, y: 90 },
      3: { x: 310, y: 240 },
      4: { x: 480, y: 160 },
      5: { x: 640, y: 180 },
      6: { x: 520, y: 320 }
    };

    const edgesGroup = document.getElementById("edges");
    const nodesGroup = document.getElementById("nodes");
    const frameNote = document.getElementById("frameNote");
    const statusText = document.getElementById("statusText");
    const frameCount = document.getElementById("frameCount");
    const queueRail = document.getElementById("queueRail");
    const log = document.getElementById("eventLog");
    const codeLines = document.querySelectorAll(".code-line");

    const runBtn = document.getElementById("runBtn");
    const resetBtn = document.getElementById("resetBtn");
    const sampleBtn = document.getElementById("sampleBtn");
    const startSelect = document.getElementById("startSelect");
    const playBtn = document.getElementById("playBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const graphInput = document.getElementById("graphInput");
    const applyGraphBtn = document.getElementById("applyGraphBtn");
    const clearGraphBtn = document.getElementById("clearGraphBtn");

    let frames = [];
    let frameIndex = 0;
    let playTimer = null;

    function computePositions(nodes) {
      const cx = 420, cy = 260;
      const n = nodes.length || 1;
      const radius = Math.min(260, 130 + n * 12);
      const pos = {};
      nodes.forEach((id, idx) => {
        const angle = (2 * Math.PI * idx) / n - Math.PI / 2;
        pos[id] = {
          x: cx + radius * Math.cos(angle),
          y: cy + radius * Math.sin(angle)
        };
      });
      return pos;
    }

    function rebuildStartOptions(nodes) {
      startSelect.innerHTML = "";
      nodes.forEach((n) => {
        const opt = document.createElement("option");
        opt.value = String(n);
        opt.textContent = n;
        startSelect.appendChild(opt);
      });
    }

    function parseGraph(text) {
      const g = {};
      const lines = text.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
      lines.forEach((line) => {
        const [left, right = ""] = line.split(":");
        if (!left) return;
        const from = Number(left.trim());
        if (Number.isNaN(from)) throw new Error(`Invalid vertex id '${left}'`);
        const edges = [];
        right.split(/[, ]+/).filter(Boolean).forEach((tok) => {
          const m = tok.match(/^(-?\d+)(?:\(([-+]?\d*\.?\d+)\))?$/);
          if (!m) throw new Error(`Invalid edge token '${tok}'`);
          const to = Number(m[1]);
          const w = m[2] !== undefined ? Number(m[2]) : 1;
          if (Number.isNaN(to) || Number.isNaN(w)) throw new Error(`Invalid edge token '${tok}'`);
          edges.push({ to, w });
        });
        g[from] = edges;
      });
      if (!Object.keys(g).length) throw new Error("No vertices parsed.");
      return g;
    }

    function setGraph(newGraph) {
      graph = newGraph;
      const nodeSet = new Set();
      Object.entries(graph).forEach(([from, edges]) => {
        nodeSet.add(Number(from));
        edges.forEach((e) => nodeSet.add(Number(e.to)));
      });
      const nodes = Array.from(nodeSet).sort((a, b) => a - b);
      positions = computePositions(nodes);
      rebuildStartOptions(nodes);
      startSelect.value = String(nodes[0]);
      renderFrame();
    }

    function appendLog(text) {
      const entry = document.createElement("div");
      entry.className = "log-entry";
      entry.textContent = text;
      log.prepend(entry);
      const entries = log.querySelectorAll(".log-entry");
      if (entries.length > 14) entries[entries.length - 1].remove();
    }

    function captureFrame(message, codeLinesArr, state) {
      frames.push({
        message,
        codeLines: codeLinesArr,
        dist: { ...state.dist },
        prev: { ...state.prev },
        settled: new Set(state.settled),
        queue: [...state.queue],
        current: state.current ?? null,
        edge: state.edge ? { ...state.edge } : null
      });
    }

    function allNodesFromGraph() {
      const nodeSet = new Set();
      Object.entries(graph).forEach(([from, edges]) => {
        nodeSet.add(Number(from));
        edges.forEach((e) => nodeSet.add(Number(e.to)));
      });
      return Array.from(nodeSet);
    }

    function dijkstra(start) {
      frames = [];
      const dist = {};
      const prev = {};
      allNodesFromGraph().forEach((k) => {
        dist[k] = Infinity;
        prev[k] = null;
      });
      dist[start] = 0;
      const settled = new Set();
      const queue = [{ node: Number(start), dist: 0 }];
      captureFrame(`Init: dist(${start})=0, push to pq.`, [2, 3, 4], { dist, prev, settled, queue });

      while (queue.length) {
        queue.sort((a, b) => a.dist - b.dist);
        const { node: u } = queue.shift();
        if (settled.has(u)) {
          captureFrame(`Skip ${u} (already settled).`, [5, 6], { dist, prev, settled, queue, current: u });
          continue;
        }
        settled.add(u);
        captureFrame(`Poll ${u}; finalize distance ${dist[u]}.`, [5, 6], { dist, prev, settled, queue, current: u });

        for (const edge of graph[u] || []) {
          const v = edge.to;
          const alt = dist[u] + edge.w;
          if (alt < dist[v]) {
            dist[v] = alt;
            prev[v] = u;
            queue.push({ node: v, dist: alt });
            captureFrame(`Relax ${u}→${v} w=${edge.w}; update dist(${v})=${alt}.`, [7, 8, 9, 10, 11, 12, 13, 14], { dist, prev, settled, queue, current: u, edge: { from: u, to: v } });
          } else {
            captureFrame(`Check ${u}→${v} w=${edge.w}; no update.`, [7, 8, 9], { dist, prev, settled, queue, current: u, edge: { from: u, to: v } });
          }
        }
      }
      if (!frames.length) captureFrame("No traversal.", [], { dist, prev, settled, queue: [] });
    }

    function renderQueue(queue) {
      queueRail.innerHTML = "";
      if (!queue.length) {
        const empty = document.createElement("div");
        empty.textContent = "Queue is empty";
        empty.style.color = "var(--muted)";
        queueRail.appendChild(empty);
        return;
      }
      const sorted = [...queue].sort((a, b) => a.dist - b.dist);
      sorted.forEach((item) => {
        const div = document.createElement("div");
        div.className = "queue-item";
        div.textContent = `${item.node} (${item.dist})`;
        queueRail.appendChild(div);
      });
    }

    function renderGraph(frame) {
      const settled = frame ? frame.settled : new Set();
      const current = frame ? frame.current : null;
      const frontier = frame ? new Set(frame.queue.map((q) => q.node)) : new Set();
      const edgeHighlight = frame ? frame.edge : null;
      const dist = frame ? frame.dist : {};

      edgesGroup.innerHTML = "";
      Object.entries(graph).forEach(([from, edges]) => {
        edges.forEach((e) => {
          const line = document.createElementNS(svgNS, "line");
          line.classList.add("edge");
          if (edgeHighlight && Number(from) === Number(edgeHighlight.from) && Number(e.to) === Number(edgeHighlight.to)) line.classList.add("highlight");
          line.setAttribute("x1", positions[from].x);
          line.setAttribute("y1", positions[from].y);
          line.setAttribute("x2", positions[e.to].x);
          line.setAttribute("y2", positions[e.to].y);
          edgesGroup.appendChild(line);

          const midX = (positions[from].x + positions[e.to].x) / 2;
          const midY = (positions[from].y + positions[e.to].y) / 2;
          const text = document.createElementNS(svgNS, "text");
          text.setAttribute("x", midX);
          text.setAttribute("y", midY - 6);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("fill", "#e5f1ff");
          text.setAttribute("font-size", "12");
          text.textContent = e.w;
          edgesGroup.appendChild(text);
        });
      });

      nodesGroup.innerHTML = "";
      Object.entries(positions).forEach(([id, pos]) => {
        const group = document.createElementNS(svgNS, "g");
        group.classList.add("node");
        if (settled.has(Number(id))) group.classList.add("settled");
        if (frontier.has(Number(id))) group.classList.add("frontier");
        if (current === Number(id)) group.classList.add("current");
        group.setAttribute("transform", `translate(${pos.x}, ${pos.y})`);

        const circle = document.createElementNS(svgNS, "circle");
        circle.setAttribute("r", 22);

        const value = document.createElementNS(svgNS, "text");
        value.classList.add("value");
        value.setAttribute("text-anchor", "middle");
        value.setAttribute("dy", "4");
        value.textContent = id;

        const meta = document.createElementNS(svgNS, "text");
        meta.classList.add("meta");
        meta.setAttribute("text-anchor", "middle");
        meta.setAttribute("dy", "28");
        const d = dist[id];
        meta.textContent = d === undefined || d === Infinity ? "∞" : `d=${d}`;

        group.appendChild(circle);
        group.appendChild(value);
        group.appendChild(meta);
        nodesGroup.appendChild(group);
      });
    }

    function highlightCode(lines) {
      codeLines.forEach((line) => {
        const id = Number(line.dataset.line);
        line.classList.toggle("highlight", lines.includes(id));
      });
    }

    function renderFrame() {
      if (!frames.length) {
        frameCount.textContent = "0 / 0";
        statusText.textContent = "Idle";
        frameNote.textContent = "Run Dijkstra to see code and graph advance together.";
        renderGraph(null);
        renderQueue([]);
        highlightCode([]);
        return;
      }
      const frame = frames[frameIndex];
      renderGraph(frame);
      renderQueue(frame.queue);
      frameNote.textContent = frame.message;
      statusText.textContent = `Frame ${frameIndex + 1} of ${frames.length}`;
      frameCount.textContent = `${frameIndex + 1} / ${frames.length}`;
      highlightCode(frame.codeLines || []);
    }

    function play(interval = 1000) {
      if (!frames.length) return;
      playBtn.disabled = true;
      pauseBtn.disabled = false;
      clearInterval(playTimer);
      playTimer = setInterval(() => {
        frameIndex = (frameIndex + 1) % frames.length;
        renderFrame();
      }, interval);
    }

    function pause() {
      playBtn.disabled = false;
      pauseBtn.disabled = true;
      clearInterval(playTimer);
    }

    function run(start) {
      pause();
      dijkstra(start);
      frameIndex = 0;
      renderFrame();
      appendLog(`Run Dijkstra from ${start}.`);
      play();
    }

    applyGraphBtn.addEventListener("click", () => {
      try {
        const parsed = parseGraph(graphInput.value);
        setGraph(parsed);
        appendLog("Applied custom graph.");
      } catch (e) {
        appendLog(`Graph parse error: ${e.message}`);
      }
    });

    clearGraphBtn.addEventListener("click", () => {
      graphInput.value = "";
      appendLog("Cleared graph input (graph unchanged).");
    });

    runBtn.addEventListener("click", () => {
      const start = Number(startSelect.value);
      run(start);
    });

    sampleBtn.addEventListener("click", () => {
      startSelect.value = "1";
      run(1);
    });

    resetBtn.addEventListener("click", () => {
      pause();
      frames = [];
      frameIndex = 0;
      renderFrame();
      appendLog("Reset state.");
    });

    prevBtn.addEventListener("click", () => {
      if (!frames.length) return;
      pause();
      frameIndex = (frameIndex - 1 + frames.length) % frames.length;
      renderFrame();
    });

    nextBtn.addEventListener("click", () => {
      if (!frames.length) return;
      pause();
      frameIndex = (frameIndex + 1) % frames.length;
      renderFrame();
    });

    playBtn.addEventListener("click", () => play());
    pauseBtn.addEventListener("click", pause);

    positions = computePositions(Object.keys(graph).map(Number));
    rebuildStartOptions(Object.keys(graph).map(Number).sort((a, b) => a - b));
    renderFrame();
  </script>
</body>
</html>
