<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dijkstra Visualizer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0f1d;
      --panel: rgba(255, 255, 255, 0.06);
      --card: rgba(255, 255, 255, 0.08);
      --stroke: rgba(255, 255, 255, 0.12);
      --text: #eaf2ff;
      --muted: #9fb3d1;
      --accent: #7cf7ff;
      --accent-2: #ff9f7f;
      --queued: #b7c9ff;
      --shadow: 0 18px 70px rgba(0, 0, 0, 0.35);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Space Grotesk", "Segoe UI", sans-serif;
      background: radial-gradient(circle at 15% 10%, rgba(124, 247, 255, 0.12), transparent 35%),
                  radial-gradient(circle at 80% 0%, rgba(255, 159, 127, 0.12), transparent 30%),
                  linear-gradient(135deg, #0b132c 0%, #090f20 55%, #070d1a 100%);
      color: var(--text);
      padding: 24px;
    }
    .page { max-width: 1240px; margin: 0 auto 40px; display: flex; flex-direction: column; gap: 16px; }
    header { display: flex; flex-wrap: wrap; gap: 10px; justify-content: space-between; align-items: baseline; }
    h1 { margin: 0; font-size: 32px; letter-spacing: -0.02em; }
    .tagline { margin: 4px 0 0; max-width: 820px; color: var(--muted); line-height: 1.4; }
    .badge { padding: 8px 12px; background: rgba(124, 247, 255, 0.1); border: 1px solid rgba(124, 247, 255, 0.45); border-radius: 12px; font-size: 14px; }
    .layout { display: grid; grid-template-columns: minmax(320px, 360px) 1fr; gap: 16px; }
    .panel { background: var(--panel); border: 1px solid var(--stroke); border-radius: 16px; padding: 16px; box-shadow: var(--shadow); }
    .panel h2 { margin: 0 0 8px; font-size: 18px; letter-spacing: 0.01em; }
    .copy { margin: 0 0 12px; color: var(--muted); line-height: 1.5; }
    label { display: block; font-size: 12px; text-transform: uppercase; letter-spacing: 0.05em; color: var(--muted); margin-bottom: 6px; }
    select, button { width: 100%; padding: 11px 12px; border-radius: 10px; border: 1px solid var(--stroke); background: rgba(255, 255, 255, 0.06); color: var(--text); font-size: 15px; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease, border 0.2s ease; }
    select:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(124, 247, 255, 0.2); }
    button.primary { background: linear-gradient(120deg, #7cf7ff 0%, #7de0ff 50%, #a9f1ff 100%); color: #04121c; border-color: rgba(124, 247, 255, 0.6); box-shadow: 0 12px 30px rgba(124, 247, 255, 0.2); font-weight: 700; }
    button.ghost { background: transparent; border-color: rgba(255, 255, 255, 0.2); box-shadow: none; }
    button:hover { transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
    .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px; }
    .controls .wide { grid-column: span 2; }
    .legend { display: grid; grid-template-columns: auto 1fr; gap: 6px 10px; padding: 12px; border-radius: 12px; border: 1px solid var(--stroke); background: var(--card); color: var(--muted); font-size: 14px; }
    .dot { width: 12px; height: 12px; border-radius: 50%; margin-top: 3px; }
    .dot.current { background: var(--accent-2); box-shadow: 0 0 0 4px rgba(255, 159, 127, 0.1); }
    .dot.settled { background: var(--accent); box-shadow: 0 0 0 4px rgba(124, 247, 255, 0.08); }
    .dot.frontier { background: var(--queued); box-shadow: 0 0 0 4px rgba(183, 201, 255, 0.1); }
    .log { margin-top: 12px; padding: 12px; background: rgba(255, 255, 255, 0.04); border-radius: 12px; border: 1px solid var(--stroke); max-height: 240px; overflow: auto; font-family: "Fira Code", monospace; font-size: 14px; line-height: 1.45; }
    .log-entry { margin: 0 0 6px; color: var(--muted); }
    .visual-panel { display: flex; flex-direction: column; gap: 12px; min-height: 540px; }
    .visual-header { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
    .status { color: var(--muted); font-size: 15px; }
    .playback { display: flex; gap: 10px; align-items: center; }
    .playback button { width: auto; padding: 9px 14px; font-size: 14px; }
    .svg-shell { position: relative; border-radius: 12px; border: 1px solid var(--stroke); background: radial-gradient(circle at 30% 30%, rgba(124, 247, 255, 0.08), transparent 40%), radial-gradient(circle at 70% 10%, rgba(255, 159, 127, 0.08), transparent 30%), rgba(255, 255, 255, 0.02); flex: 1; overflow: hidden; min-height: 420px; }
    svg { width: 100%; height: 100%; display: block; filter: drop-shadow(0 10px 22px rgba(0, 0, 0, 0.25)); }
    line.edge { stroke: #7f8fb0; stroke-width: 2.4; stroke-linecap: round; opacity: 0.65; transition: opacity 0.25s ease, stroke 0.25s ease; }
    line.edge.highlight { stroke: var(--accent-2); opacity: 0.95; }
    g.node { transition: transform 0.3s ease; }
    g.node circle { fill: url(#nodeGradient); stroke: #e5f1ff; stroke-width: 1.5; transition: fill 0.2s ease, stroke 0.2s ease, r 0.2s ease, opacity 0.2s ease; }
    g.node.settled circle { fill: #c5f5ff; stroke: var(--accent); }
    g.node.frontier circle { fill: #dfe6ff; stroke: var(--queued); }
    g.node.current circle { fill: #ffd5c4; stroke: var(--accent-2); r: 24; }
    g.node text.value { fill: #04121c; font-weight: 700; font-size: 14px; }
    g.node text.meta { fill: #f8fbff; font-size: 11px; opacity: 0.8; }
    .frame-footnote { position: absolute; left: 12px; bottom: 12px; background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 9px 10px; border: 1px solid rgba(255, 255, 255, 0.12); color: var(--muted); font-size: 14px; max-width: 72%; }
    .timeline { display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--muted); }
    .timeline strong { color: var(--text); letter-spacing: 0.02em; }
    .queue-rail { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .queue-item { min-width: 60px; padding: 8px 10px; border-radius: 10px; background: rgba(183, 201, 255, 0.12); border: 1px solid rgba(183, 201, 255, 0.4); color: var(--text); font-weight: 700; text-align: center; box-shadow: 0 8px 20px rgba(183, 201, 255, 0.2); }
    @media (max-width: 980px) { .layout { grid-template-columns: 1fr; } body { padding: 18px; } }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div>
        <h1>Dijkstra Visualizer</h1>
        <p class="tagline">Sample weighted graph; watch the priority queue evolve, distances relax, and settled nodes freeze.</p>
      </div>
      <div class="badge">Time: O((V+E) log V)</div>
    </header>

    <div class="layout">
      <section class="panel">
        <h2>Controls</h2>
        <p class="copy">Choose a start vertex and run; step through queue pops and relaxations.</p>
        <div class="controls">
          <div>
            <label for="startSelect">Start vertex</label>
            <select id="startSelect">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </div>
          <div class="wide" style="display:flex; gap:10px;">
            <button id="runBtn" class="primary">Run Dijkstra</button>
            <button id="resetBtn" class="ghost">Reset</button>
          </div>
          <div class="wide">
            <button id="sampleBtn" class="ghost">Replay sample (start = 1)</button>
          </div>
        </div>

        <div class="legend">
          <span class="dot current"></span><span>Current (popped) vertex</span>
          <span class="dot settled"></span><span>Settled (distance finalized)</span>
          <span class="dot frontier"></span><span>In priority queue (candidate)</span>
        </div>

        <div>
          <label>Priority queue (min-dist)</label>
          <div class="queue-rail" id="queueRail"></div>
        </div>

        <div class="log" id="eventLog" aria-live="polite"></div>
      </section>

      <section class="panel visual-panel">
        <div class="visual-header">
          <div class="status" id="statusText">Waiting for an operation…</div>
          <div class="playback">
            <button id="prevBtn" class="ghost">Prev</button>
            <button id="playBtn" class="primary">Play</button>
            <button id="pauseBtn" class="ghost" disabled>Pause</button>
            <button id="nextBtn" class="ghost">Next</button>
          </div>
        </div>

        <div class="svg-shell">
          <svg id="graphSvg" viewBox="0 0 840 520" aria-label="Dijkstra animation">
            <defs>
              <linearGradient id="nodeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#f1fbff" />
                <stop offset="100%" stop-color="#b6e8ff" />
              </linearGradient>
            </defs>
            <g id="edges"></g>
            <g id="nodes"></g>
          </svg>
          <div class="frame-footnote" id="frameNote">Run Dijkstra to see queue pops and relaxations.</div>
        </div>

        <div class="timeline">
          <strong id="frameCount">0 / 0</strong>
          <span>frames captured</span>
        </div>
      </section>
    </div>
  </div>

  <script>
    const svgNS = "http://www.w3.org/2000/svg";

    const graph = {
      1: [{ to: 2, w: 7 }, { to: 3, w: 9 }, { to: 6, w: 14 }],
      2: [{ to: 3, w: 10 }, { to: 4, w: 15 }],
      3: [{ to: 4, w: 11 }, { to: 6, w: 2 }],
      4: [{ to: 5, w: 6 }],
      5: [{ to: 6, w: 9 }],
      6: []
    };

    const positions = {
      1: { x: 140, y: 140 },
      2: { x: 300, y: 90 },
      3: { x: 310, y: 240 },
      4: { x: 480, y: 160 },
      5: { x: 640, y: 180 },
      6: { x: 520, y: 320 }
    };

    const edgesGroup = document.getElementById("edges");
    const nodesGroup = document.getElementById("nodes");
    const frameNote = document.getElementById("frameNote");
    const statusText = document.getElementById("statusText");
    const frameCount = document.getElementById("frameCount");
    const queueRail = document.getElementById("queueRail");
    const log = document.getElementById("eventLog");

    const runBtn = document.getElementById("runBtn");
    const resetBtn = document.getElementById("resetBtn");
    const sampleBtn = document.getElementById("sampleBtn");
    const startSelect = document.getElementById("startSelect");
    const playBtn = document.getElementById("playBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");

    let frames = [];
    let frameIndex = 0;
    let playTimer = null;

    function appendLog(text) {
      const entry = document.createElement("div");
      entry.className = "log-entry";
      entry.textContent = text;
      log.prepend(entry);
      const entries = log.querySelectorAll(".log-entry");
      if (entries.length > 14) entries[entries.length - 1].remove();
    }

    function captureFrame(message, state) {
      frames.push({
        message,
        dist: { ...state.dist },
        prev: { ...state.prev },
        settled: new Set(state.settled),
        queue: [...state.queue],
        current: state.current ?? null,
        edge: state.edge ? { ...state.edge } : null
      });
    }

    function dijkstra(start) {
      frames = [];
      const dist = {};
      const prev = {};
      Object.keys(graph).forEach((k) => {
        dist[k] = Infinity;
        prev[k] = null;
      });
      dist[start] = 0;
      const settled = new Set();
      const queue = [{ node: Number(start), dist: 0 }];
      captureFrame(`Init: dist(${start})=0, push to queue.`, { dist, prev, settled, queue });

      while (queue.length) {
        queue.sort((a, b) => a.dist - b.dist);
        const { node: u } = queue.shift();
        if (settled.has(u)) {
          captureFrame(`Skip ${u} (already settled).`, { dist, prev, settled, queue, current: u });
          continue;
        }
        settled.add(u);
        captureFrame(`Pop ${u}, settle distance ${dist[u].toFixed(0)}.`, { dist, prev, settled, queue, current: u });

        for (const edge of graph[u] || []) {
          const v = edge.to;
          const alt = dist[u] + edge.w;
          if (alt < dist[v]) {
            dist[v] = alt;
            prev[v] = u;
            queue.push({ node: v, dist: alt });
            captureFrame(`Relax ${u}→${v} w=${edge.w}: dist(${v})=${alt}.`, { dist, prev, settled, queue, current: u, edge: { from: u, to: v } });
          } else {
            captureFrame(`Check ${u}→${v} w=${edge.w}: no update.`, { dist, prev, settled, queue, current: u, edge: { from: u, to: v } });
          }
        }
      }
      if (!frames.length) captureFrame("No traversal.", { dist, prev, settled, queue: [] });
    }

    function renderQueue(queue) {
      queueRail.innerHTML = "";
      if (!queue.length) {
        const empty = document.createElement("div");
        empty.textContent = "Queue is empty";
        empty.style.color = "var(--muted)";
        queueRail.appendChild(empty);
        return;
      }
      const sorted = [...queue].sort((a, b) => a.dist - b.dist);
      sorted.forEach((item) => {
        const div = document.createElement("div");
        div.className = "queue-item";
        div.textContent = `${item.node} (${item.dist})`;
        queueRail.appendChild(div);
      });
    }

    function renderGraph(frame) {
      const settled = frame ? frame.settled : new Set();
      const current = frame ? frame.current : null;
      const frontier = frame ? new Set(frame.queue.map((q) => q.node)) : new Set();
      const edgeHighlight = frame ? frame.edge : null;
      const dist = frame ? frame.dist : {};

      edgesGroup.innerHTML = "";
      Object.entries(graph).forEach(([from, edges]) => {
        edges.forEach((e) => {
          const line = document.createElementNS(svgNS, "line");
          line.classList.add("edge");
          if (edgeHighlight && Number(from) === Number(edgeHighlight.from) && Number(e.to) === Number(edgeHighlight.to)) line.classList.add("highlight");
          line.setAttribute("x1", positions[from].x);
          line.setAttribute("y1", positions[from].y);
          line.setAttribute("x2", positions[e.to].x);
          line.setAttribute("y2", positions[e.to].y);
          edgesGroup.appendChild(line);

          const midX = (positions[from].x + positions[e.to].x) / 2;
          const midY = (positions[from].y + positions[e.to].y) / 2;
          const text = document.createElementNS(svgNS, "text");
          text.setAttribute("x", midX);
          text.setAttribute("y", midY - 6);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("fill", "#e5f1ff");
          text.setAttribute("font-size", "12");
          text.textContent = e.w;
          edgesGroup.appendChild(text);
        });
      });

      nodesGroup.innerHTML = "";
      Object.entries(positions).forEach(([id, pos]) => {
        const group = document.createElementNS(svgNS, "g");
        group.classList.add("node");
        if (settled.has(Number(id))) group.classList.add("settled");
        if (frontier.has(Number(id))) group.classList.add("frontier");
        if (current === Number(id)) group.classList.add("current");
        group.setAttribute("transform", `translate(${pos.x}, ${pos.y})`);

        const circle = document.createElementNS(svgNS, "circle");
        circle.setAttribute("r", 22);

        const value = document.createElementNS(svgNS, "text");
        value.classList.add("value");
        value.setAttribute("text-anchor", "middle");
        value.setAttribute("dy", "4");
        value.textContent = id;

        const meta = document.createElementNS(svgNS, "text");
        meta.classList.add("meta");
        meta.setAttribute("text-anchor", "middle");
        meta.setAttribute("dy", "28");
        const d = dist[id];
        meta.textContent = d === undefined || d === Infinity ? "∞" : `d=${d}`;

        group.appendChild(circle);
        group.appendChild(value);
        group.appendChild(meta);
        nodesGroup.appendChild(group);
      });
    }

    function renderFrame() {
      if (!frames.length) {
        frameCount.textContent = "0 / 0";
        statusText.textContent = "Idle";
        frameNote.textContent = "Run Dijkstra to see queue pops and relaxations.";
        renderGraph(null);
        renderQueue([]);
        return;
      }
      const frame = frames[frameIndex];
      renderGraph(frame);
      renderQueue(frame.queue);
      frameNote.textContent = frame.message;
      statusText.textContent = `Frame ${frameIndex + 1} of ${frames.length}`;
      frameCount.textContent = `${frameIndex + 1} / ${frames.length}`;
    }

    function play(interval = 1000) {
      if (!frames.length) return;
      playBtn.disabled = true;
      pauseBtn.disabled = false;
      clearInterval(playTimer);
      playTimer = setInterval(() => {
        frameIndex = (frameIndex + 1) % frames.length;
        renderFrame();
      }, interval);
    }

    function pause() {
      playBtn.disabled = false;
      pauseBtn.disabled = true;
      clearInterval(playTimer);
    }

    function run(start) {
      pause();
      dijkstra(start);
      frameIndex = 0;
      renderFrame();
      appendLog(`Run Dijkstra from ${start}.`);
      play();
    }

    runBtn.addEventListener("click", () => {
      const start = Number(startSelect.value);
      run(start);
    });

    sampleBtn.addEventListener("click", () => {
      startSelect.value = "1";
      run(1);
    });

    resetBtn.addEventListener("click", () => {
      pause();
      frames = [];
      frameIndex = 0;
      renderFrame();
      appendLog("Reset state.");
    });

    prevBtn.addEventListener("click", () => {
      if (!frames.length) return;
      pause();
      frameIndex = (frameIndex - 1 + frames.length) % frames.length;
      renderFrame();
    });

    nextBtn.addEventListener("click", () => {
      if (!frames.length) return;
      pause();
      frameIndex = (frameIndex + 1) % frames.length;
      renderFrame();
    });

    playBtn.addEventListener("click", () => play());
    pauseBtn.addEventListener("click", pause);

    renderFrame();
  </script>
</body>
</html>
